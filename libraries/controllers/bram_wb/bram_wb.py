#==============================================================================#
#                                                                              # 
#      BRAM with wishbone interface wrapper and simulation model               # 
#                                                                              # 
#      Module name: bram_wb_wrapper                                            # 
#      Desc: wraps the verilog bram_wb and provides a model for simulation     # 
#      Date: June 2012                                                         # 
#      Developer: Wesley New                                                   # 
#      Licence: GNU General Public License ver 3                               # 
#      Notes:                                                                  # 
#                                                                              # 
#==============================================================================#

from myhdl import *
#from wishbone import wishbone

class bram_wb:

   #def __init__(self, module_name, HAS_INTERRUPT, BUS_DATA_WIDTH = 32, BUS_ADDR_WIDTH = 1, BUS_BASE_ADDR = 0, BUS_HIGH_ADDR = 0):
   #   self._bus_interface = "wishbone"        # static parameter, "none", "wishbone", "epb"
   #   self._wb_mem_size   = 32                # static parameter,  memory requirements for this module, 1 addr = 32bits
   #   self.module_name    = module_name       # the name of the module
   #   self.HAS_INTERRUPT  = HAS_INTERRUPT     # set in the module form 0 = no, 1 = yes
   #   self.BUS_DATA_WIDTH = BUS_DATA_WIDTH    # set globaly for devices on the bus
   #   self.BUS_ADDR_WIDTH = BUS_ADDR_WIDTH    # set globaly for devices on the bus
   #   self.BUS_BASE_ADDR  = BUS_BASE_ADDR     # base address, this is generated by bus management
   #   self.BUS_HIGH_ADDR  = BUS_HIGH_ADDR     # high address, this is generated by bus management

   
   #def design_settings(self, system_settings_object):
   #   # take in bus params and set the BUS_HIGH and BUS_LOW values etc.
   #   x = 1 + 1
   
   
   def bram_wb_wrapper(self,
         #===============
         # fabric ports
         #===============
         fabric_clk,
         fabric_rst,
         fabric_we,
         fabric_addr,
         fabric_data_in,
         fabric_data_out,
   
         #===========
         # wb ports
         #===========
         wbs_clk_i,
         wbs_rst_i,
         wbs_cyc_i,
         wbs_stb_i,
         wbs_we_i,
         wbs_sel_i,
         wbs_adr_i,
         wbs_dat_i,
         wbs_dat_o,
         wbs_ack_o,

         #=============
         # Parameters
         #=============
         module_name    = 1,
         SLI            = 0, # slave id, must be unique to each instantiation
         DEV_BASE_ADDR  = 0,
         DEV_HIGH_ADDR  = 32,
         BUS_DATA_WIDTH = 32,
         BUS_ADDR_WIDTH = 8,
         BUS_BE_WIDTH   = 4,
         RAM_ADDR_WIDTH = 8
      ):
      
      # the conversion of user defined code does not currently support self.
      # so this is a hack until support for this is implemented.
      #module_name    = self.module_name
      #HAS_INTERRUPT  = self.HAS_INTERRUPT
      #BUS_DATA_WIDTH = self.BUS_DATA_WIDTH
      #BUS_ADDR_WIDTH = self.BUS_ADDR_WIDTH
      #BUS_BASE_ADDR  = self.BUS_BASE_ADDR 
      #BUS_HIGH_ADDR  = self.BUS_HIGH_ADDR 
      
      #========================
      # TODO:Simulation Logic
      #========================
      @always(wbs_clk_i.posedge)
      def logic():
         temp = 1
      
      # removes warning when converting to hdl
      fabric_data_out.driven = "wire"
      wbs_dat_o.driven       = "wire"
      wbs_ack_o.driven       = "wire"

      print SLI
      SLI = SLI-1
   
      return logic
  

   #========================
   # Counter Instantiation
   #========================
   # as an attribute on the wrapper function
   bram_wb_wrapper.verilog_code = \
   """
   bram_wb
   #(
      .DEV_BASE_ADDR  ($DEV_BASE_ADDR),
      .DEV_HIGH_ADDR  ($DEV_HIGH_ADDR),
      .BUS_DATA_WIDTH ($BUS_DATA_WIDTH),
      .BUS_ADDR_WIDTH ($BUS_ADDR_WIDTH),
      .BUS_BE_WIDTH   ($BUS_BE_WIDTH), 
      .RAM_ADDR_WIDTH ($RAM_ADDR_WIDTH)
   ) bram_wb_$module_name (
     
      .fabric_clk      ($fabric_clk),
      .fabric_rst      ($fabric_rst),
      .fabric_we       ($fabric_we),
      .fabric_addr     ($fabric_addr),
      .fabric_data_in  ($fabric_data_in),
      .fabric_data_out ($fabric_data_out),
                                       
      .wbs_clk_i       ($wbs_clk_i),
      .wbs_rst_i       ($wbs_rst_i),
      .wbs_cyc_i       ($wbs_cyc_i[$SLI]),
      .wbs_stb_i       ($wbs_stb_i[$SLI]),
      .wbs_we_i        ($wbs_we_i),
      .wbs_sel_i       ($wbs_sel_i),
      .wbs_adr_i       ($wbs_adr_i),
      .wbs_dat_i       ($wbs_dat_i),
      .wbs_dat_o       ($wbs_dat_o[(($SLI+1)*32)-1:$SLI*32]),
      .wbs_ack_o       ($wbs_ack_o[$SLI])
   );
   """


#=======================================
# For testing of conversion to verilog
#=======================================
def convert():
   
   module_name     = 1
   SLI             = 1 # slave id, must be unique to each instantiation
   DEV_BASE_ADDR   = 0
   DEV_HIGH_ADDR   = 32
   BUS_DATA_WIDTH  = 32
   BUS_ADDR_WIDTH  = 8 
   BUS_BE_WIDTH    = 4

   x = bram_wb()

   #x = bram_wb(module_name    = "1",
   #            HAS_INTERRUPT  = "0",
   #            BUS_DATA_WIDTH = 32,
   #            BUS_ADDR_WIDTH = 1,
   #            BUS_BASE_ADDR  = 0,
   #            BUS_HIGH_ADDR  = 0)

   fabric_clk, fabric_rst, fabric_we = [Signal(bool(0))  for i in range(3)] 
   fabric_addr = Signal(intbv(0)[BUS_ADDR_WIDTH:]) 
   fabric_data_in, fabric_data_out                = [Signal(intbv(0)[BUS_DATA_WIDTH:]) for i in range(2)] 
   wbs_clk_i, wbs_rst_i, wbs_we_i      = [Signal(bool(0))  for i in range(3)]
   wbs_sel_i = Signal(intbv(0)[BUS_BE_WIDTH:])
   wbs_cyc_i = Signal(intbv(0)[SLI:])
   wbs_stb_i = Signal(intbv(0)[SLI:])
   wbs_adr_i = Signal(intbv(0)[BUS_ADDR_WIDTH:])
   wbs_dat_i = Signal(intbv(0)[BUS_DATA_WIDTH:])
   wbs_dat_o = Signal(intbv(0)[BUS_DATA_WIDTH*(SLI):])
   wbs_ack_o = Signal(intbv(0)[SLI:])

   toVerilog(x.bram_wb_wrapper, 
             fabric_clk      = fabric_clk,
             fabric_rst      = fabric_rst,
             fabric_we       = fabric_we,
             fabric_addr     = fabric_addr,
             fabric_data_in  = fabric_data_in,
             fabric_data_out = fabric_data_out,
             wbs_clk_i       = wbs_clk_i,
             wbs_rst_i       = wbs_rst_i,
             wbs_we_i        = wbs_we_i,
             wbs_cyc_i       = wbs_cyc_i,
             wbs_sel_i       = wbs_sel_i,
             wbs_stb_i       = wbs_stb_i,
             wbs_adr_i       = wbs_adr_i,
             wbs_dat_i       = wbs_dat_i,
             wbs_dat_o       = wbs_dat_o,
             wbs_ack_o       = wbs_ack_o,
             module_name     = module_name,
             SLI             = SLI,
             DEV_BASE_ADDR   = DEV_BASE_ADDR,
             DEV_HIGH_ADDR   = DEV_HIGH_ADDR,
             BUS_DATA_WIDTH  = BUS_DATA_WIDTH,
             BUS_ADDR_WIDTH  = BUS_ADDR_WIDTH,
             BUS_BE_WIDTH    = BUS_BE_WIDTH
            )
   

if __name__ == "__main__":
   convert()
   
